<UnitDef>
  <UnitName>NewUnit</UnitName>
  <TypeDefs/>
  <ClassDefs>
    <ClassDef Name="HsPropertyDef">
      <Settings>
        <InHeritsFrom/>
        <UseCustomClass>false</UseCustomClass>
        <UseInterface>true</UseInterface>
        <UseStrict>true</UseStrict>
        <MakeList>true</MakeList>
        <UseEnumerator>true</UseEnumerator>
        <UseNestedClass>false</UseNestedClass>
        <TrackChange>false</TrackChange>
        <DataType>dsNone</DataType>
      </Settings>
      <Properies>
        <Property Name="PropertyName" PropertyType="ptString">
          <IsReadOnly>false</IsReadOnly>
          <IsDataAware>false</IsDataAware>
          <MaxLen>0</MaxLen>
        </Property>
        <Property Name="PropertyType" PropertyType="ptByte">
          <IsReadOnly>false</IsReadOnly>
          <IsDataAware>false</IsDataAware>
        </Property>
        <Property Name="IsDataAware" PropertyType="ptBoolean">
          <IsReadOnly>false</IsReadOnly>
          <IsDataAware>false</IsDataAware>
        </Property>
        <Property Name="IsReadOnly" PropertyType="ptBoolean">
          <IsReadOnly>false</IsReadOnly>
          <IsDataAware>false</IsDataAware>
        </Property>
        <Property Name="PropertyClass" PropertyType="ptString">
          <IsReadOnly>false</IsReadOnly>
          <IsDataAware>false</IsDataAware>
          <MaxLen>0</MaxLen>
        </Property>
        <Property Name="InterfaceName" PropertyType="ptString">
          <IsReadOnly>false</IsReadOnly>
          <IsDataAware>false</IsDataAware>
          <MaxLen>0</MaxLen>
        </Property>
        <Property Name="InterfaceImplementor" PropertyType="ptString">
          <IsReadOnly>false</IsReadOnly>
          <IsDataAware>false</IsDataAware>
          <MaxLen>0</MaxLen>
        </Property>
        <Property Name="IsId" PropertyType="ptBoolean">
          <IsReadOnly>false</IsReadOnly>
          <IsDataAware>false</IsDataAware>
        </Property>
        <Property Name="FieldName" PropertyType="ptString">
          <IsReadOnly>false</IsReadOnly>
          <IsDataAware>false</IsDataAware>
          <MaxLen>0</MaxLen>
        </Property>
        <Property Name="MaxLen" PropertyType="ptInteger">
          <IsReadOnly>false</IsReadOnly>
          <IsDataAware>false</IsDataAware>
        </Property>
        <Property Name="IsBigEndian" PropertyType="ptBoolean">
          <IsReadOnly>false</IsReadOnly>
          <IsDataAware>false</IsDataAware>
        </Property>
      </Properies>
      <Procedures>
        <Procedure>
          <Parameters>Const AIsForRecord : Boolean = False</Parameters>
          <ProcedureName>GetVariableDefinition</ProcedureName>
          <ProcedureImpl>Begin
  If AIsForRecord Then
    Result := FPropertyName + ':' + GetPropertyTypeStr() + ';'
  Else
    Result := 'F' + FPropertyName + ':' + GetPropertyTypeStr() + ';';
End;
</ProcedureImpl>
          <ResultType>rtString</ResultType>
          <Scope>fsProtected</Scope>
          <IsVirtual>false</IsVirtual>
          <IsAbstract>false</IsAbstract>
          <IsOverRide>false</IsOverRide>
          <IsReIntroduce>false</IsReIntroduce>
          <IsOverLoad>false</IsOverLoad>
          <ShowInInterface>true</ShowInInterface>
        </Procedure>
        <Procedure>
          <Parameters>Const AHaveGetter, AHaveSetter : Boolean</Parameters>
          <ProcedureName>GetPropertyDefinition</ProcedureName>
          <ProcedureImpl>Begin
  Result := 'Property ' + FPropertyName + ':' + GetPropertyTypeStr() + ' Read ';

  If AHaveGetter Then
    Result := Result + 'Get'
  Else
    Result := Result + 'F';

  Result := Result + FPropertyName;

  If FIsReadOnly Then
    Result := Result + ';'
  Else
  Begin
    Result := Result + ' Write ';
    If (AHaveSetter Or ((FPropertyType = ptString) And (FMaxLen &gt; 0))) Then
      Result := Result + 'Set'
    Else
      Result := Result + 'F';

    Result := Result + FPropertyName + ';'
  End;
End;
</ProcedureImpl>
          <ResultType>rtString</ResultType>
          <Scope>fsProtected</Scope>
          <IsVirtual>false</IsVirtual>
          <IsAbstract>false</IsAbstract>
          <IsOverRide>false</IsOverRide>
          <IsReIntroduce>false</IsReIntroduce>
          <IsOverLoad>false</IsOverLoad>
          <ShowInInterface>true</ShowInInterface>
        </Procedure>
        <Procedure>
          <Parameters>Const AHaveGetter, AHaveSetter, AIsVirtual : Boolean; Const AIsAbstract : Boolean = False; Const AIndent : Integer = 0</Parameters>
          <ProcedureName>GetPropertyFunctions</ProcedureName>
          <ProcedureImpl>Var lStr : String;
Begin
  Result := '';

  With TStringList.Create() Do
  Try
    If AHaveGetter Then
    Begin
      lStr := StringOfChar(' ', AIndent * 2) + 'Function  Get' + FPropertyName + '() : ' + GetPropertyTypeStr() + ';';
      If AIsVirtual Then
        lStr := lStr + ' Virtual;';
      If AIsAbstract Then
        lStr := lStr + ' Abstract;';

      Add(lStr);
    End;

    If Not FIsReadOnly And (AHaveSetter Or ((FPropertyType = ptString) And (FMaxLen &gt; 0))) Then
    Begin
      lStr := StringOfChar(' ', AIndent * 2) + 'Procedure Set' + FPropertyName + '(Const A' + FPropertyName + ' : ' + GetPropertyTypeStr() + ');';
      If AIsVirtual Then
        lStr := lStr + ' Virtual;';
      If AIsAbstract Then
        lStr := lStr + ' Abstract;';

      Add(lStr);
    End;

    Result := Text;

    Finally
      Free();
  End;
End;
</ProcedureImpl>
          <ResultType>rtString</ResultType>
          <Scope>fsProtected</Scope>
          <IsVirtual>false</IsVirtual>
          <IsAbstract>false</IsAbstract>
          <IsOverRide>false</IsOverRide>
          <IsReIntroduce>false</IsReIntroduce>
          <IsOverLoad>false</IsOverLoad>
          <ShowInInterface>true</ShowInInterface>
        </Procedure>
        <Procedure>
          <Parameters>Const AHaveGetter, AHaveSetter, ATrackChange : Boolean; Const ADataType : THsDataSource = dsNone</Parameters>
          <ProcedureName>GetPropertyFunctionImplementation</ProcedureName>
          <ProcedureImpl>  Procedure GetJSonGetterCode(AList : TStringList);
  Begin
    Case FPropertyType Of
      ptInteger, ptByte : AList.Add('  Result := I[''' + FPropertyName + '''];');
      ptDouble : AList.Add('  Result := D[''' + FPropertyName + '''];');
      ptCurrency : AList.Add('  Result := C[''' + FPropertyName + '''];');
      ptString, ptWideString : AList.Add('  Result := S[''' + FPropertyName + '''];');
      ptBoolean : AList.Add('  Result := B[''' + FPropertyName + '''];');
      ptInterface :
      Begin
        AList.Add('  If O[''' + FPropertyName + '''] = Nil Then');
        AList.Add('    O[''' + FPropertyName + '''] := ' + FInterfaceImplementor + '.Create();');
        AList.Add('');
        AList.Add('  Result := O[''' + FPropertyName + '''] As ' + FInterfaceName);
      End;
    End;
  End;

  Procedure GetXmlGetterCode(AList : TStringList);
  Begin
    Case FPropertyType Of
      ptInteger, ptSingle, ptByte : AList.Add('  Result := ChildNodes[''' + FPropertyName + '''].AsInteger;');
      ptDouble : AList.Add('  Result := ChildNodes[''' + FPropertyName + '''].AsFloat;');
      ptCurrency : AList.Add('  Result := ChildNodes[''' + FPropertyName + '''].AsCurrency;');
      ptDate, ptTime, ptDateTime : AList.Add('  Result := ChildNodes[''' + FPropertyName + '''].AsDateTime;');
      ptBoolean : AList.Add('  Result := ChildNodes[''' + FPropertyName + '''].AsBoolean;');
      ptString, ptWideString : AList.Add('  Result := ChildNodes[''' + FPropertyName + '''].AsString;');
      ptInterface : AList.Add('  Result := ChildNodes[''' + FPropertyName + '''] As ' + FInterfaceName + ';');
    End;
  End;

  Procedure GetJSonSetterCode(AList : TStringList);
  Begin
    Case FPropertyType Of
      ptInteger, ptByte :
      Begin
        If ATrackChange Then
        Begin
          AList.Add('  If I[''' + FPropertyName + '''] &lt;&gt; A' + FPropertyName + ' Then');
          AList.Add('  Begin');
          AList.Add('    I[''' + FPropertyName + '''] := A' + FPropertyName + ';');
        End
        Else
          AList.Add('  I[''' + FPropertyName + '''] := A' + FPropertyName + ';');
      End;

      ptDouble :
      Begin
        If ATrackChange Then
        Begin
          AList.Add('  If D[''' + FPropertyName + '''] &lt;&gt; A' + FPropertyName + ' Then');
          AList.Add('  Begin');
          AList.Add('    D[''' + FPropertyName + '''] := A' + FPropertyName + ';');
        End
        Else
          AList.Add('  D[''' + FPropertyName + '''] := A' + FPropertyName + ';');
      End;

      ptCurrency :
      Begin
        If ATrackChange Then
        Begin
          AList.Add('  If C[''' + FPropertyName + '''] &lt;&gt; A' + FPropertyName + ' Then');
          AList.Add('  Begin');
          AList.Add('    C[''' + FPropertyName + '''] := A' + FPropertyName + ';');
        End
        Else
          AList.Add('  C[''' + FPropertyName + '''] := A' + FPropertyName + ';');
      End;

      ptString, ptWideString :
      Begin
        If ATrackChange Then
        Begin
          AList.Add('  If S[''' + FPropertyName + '''] &lt;&gt; A' + FPropertyName + ' Then');
          AList.Add('  Begin');
          AList.Add('    S[''' + FPropertyName + '''] := A' + FPropertyName + ';');
        End
        Else
          AList.Add('  S[''' + FPropertyName + '''] := A' + FPropertyName + ';');
      End;

      ptBoolean :
      Begin
        If ATrackChange Then
        Begin
          AList.Add('  If B[''' + FPropertyName + '''] &lt;&gt; A' + FPropertyName + ' Then');
          AList.Add('  Begin');
          AList.Add('    B[''' + FPropertyName + '''] := A' + FPropertyName + ';');
        End
        Else
          AList.Add('  B[''' + FPropertyName + '''] := A' + FPropertyName + ';');
      End;

      ptInterface :
      Begin
        AList.Add('  O[''' + FPropertyName + '''] := A' + FPropertyName + ';');
      End;
    End;
  End;

  Procedure GetXmlSetterCode(AList : TStringList);
  Begin
    Case FPropertyType Of
      ptInteger, ptSingle, ptByte : AList.Add('  ChildNodes[''' + FPropertyName + '''].AsInteger := A' + FPropertyName + ';');
      ptDouble : AList.Add('  ChildNodes[''' + FPropertyName + '''].AsFloat := A' + FPropertyName + ';');
      ptCurrency : AList.Add('  ChildNodes[''' + FPropertyName + '''].AsCurrency := A' + FPropertyName + ';');
      ptDate, ptTime, ptDateTime : AList.Add('  ChildNodes[''' + FPropertyName + '''].AsDateTime := A' + FPropertyName + ';');
      ptBoolean : AList.Add('  ChildNodes[''' + FPropertyName + '''].AsBoolean := A' + FPropertyName + ';');
      ptString, ptWideString : AList.Add('  ChildNodes[''' + FPropertyName + '''].AsString := A' + FPropertyName + ';');
    End;
  End;

Var lResult : TStringList;
Begin
  Result := '';
  lResult := TStringList.Create();
  With lResult Do
  Try
    If AHaveGetter Then
    Begin
      Add('Function T%ClassName%.Get' + FPropertyName + '() : ' + GetPropertyTypeStr() + ';');
      Add('Begin');
      Case ADataType Of
        dsJSon : GetJSonGetterCode(lResult);
        dsXML : GetXmlGetterCode(lResult);

        Else
          Add('  Result := F' + FPropertyName + ';');
      End;
      Add('End;');
    End;

    If Not FIsReadOnly And (AHaveSetter Or ((FPropertyType = ptString) And (FMaxLen &gt; 0))) Then
    Begin
      Add('');

      Add('Procedure T%ClassName%.Set' + FPropertyName + '(Const A' + FPropertyName + ' : ' + GetPropertyTypeStr() + ');');
      Add('Begin');

      If (FPropertyType = ptString) And (FMaxLen &gt; 0) Then
      Begin
        Add('  If Length(A' + FPropertyName + ') &gt; ' + IntToStr(FMaxLen) + ' Then');
        Add('    Raise Exception.Create(''MaxLength for property ' + FPropertyName + ' is : ' + IntToStr(FMaxLen) + ''');');
      End;

      If ATrackChange Then
      Begin
        Case ADataType Of
          dsJSon : GetJSonSetterCode(lResult);
          dsXml : GetXmlSetterCode(lResult);
          
          Else
            Add('  If F' + FPropertyName + ' &lt;&gt; A' + FPropertyName + ' Then');
            Add('  Begin');
            Add('    F' + FPropertyName + ' := A' + FPropertyName + ';');
        End;
        Add('    Changed();');
        Add('  End;');
      End
      Else
      Begin
        Case ADataType Of
          dsJSon : GetJSonSetterCode(lResult);
          dsXml : GetXmlSetterCode(lResult);

          Else
            Add('  F' + FPropertyName + ' := A' + FPropertyName + ';');
        End;
      End;

      Add('End;');
    End;

    Result := Text;

    Finally
      Free();
  End;
End;
</ProcedureImpl>
          <ResultType>rtNone</ResultType>
          <Scope>fsProtected</Scope>
          <IsVirtual>false</IsVirtual>
          <IsAbstract>false</IsAbstract>
          <IsOverRide>false</IsOverRide>
          <IsReIntroduce>false</IsReIntroduce>
          <IsOverLoad>false</IsOverLoad>
          <ShowInInterface>true</ShowInInterface>
        </Procedure>
      </Procedures>
    </ClassDef>
    <ClassDef Name="HsTypeDef">
      <Settings>
        <InHeritsFrom/>
        <UseCustomClass>false</UseCustomClass>
        <UseInterface>true</UseInterface>
        <UseStrict>true</UseStrict>
        <MakeList>true</MakeList>
        <UseEnumerator>true</UseEnumerator>
        <UseNestedClass>false</UseNestedClass>
        <TrackChange>false</TrackChange>
        <DataType>dsNone</DataType>
      </Settings>
      <Properies>
        <Property Name="TypeDefType" PropertyType="ptByte">
          <IsReadOnly>false</IsReadOnly>
          <IsDataAware>false</IsDataAware>
        </Property>
        <Property Name="TypeDefName" PropertyType="ptString">
          <IsReadOnly>false</IsReadOnly>
          <IsDataAware>false</IsDataAware>
          <MaxLen>0</MaxLen>
        </Property>
        <Property Name="TypeDefValue" PropertyType="ptStringList">
          <IsReadOnly>false</IsReadOnly>
          <IsDataAware>false</IsDataAware>
        </Property>
        <Property Name="TypeDefMembers" PropertyType="ptInterface">
          <IsReadOnly>true</IsReadOnly>
          <InterfaceName>IHsPropertyDefs</InterfaceName>
          <InterfaceImplementor>THsPropertyDefs</InterfaceImplementor>
          <IsDataAware>false</IsDataAware>
        </Property>
      </Properies>
      <Procedures>
        <Procedure>
          <Parameters/>
          <ProcedureName>GetTypeDefDefinition</ProcedureName>
          <ProcedureImpl>Begin

End;
</ProcedureImpl>
          <ResultType>rtString</ResultType>
          <Scope>fsProtected</Scope>
          <IsVirtual>false</IsVirtual>
          <IsAbstract>false</IsAbstract>
          <IsOverRide>false</IsOverRide>
          <IsReIntroduce>false</IsReIntroduce>
          <IsOverLoad>false</IsOverLoad>
          <ShowInInterface>true</ShowInInterface>
        </Procedure>
      </Procedures>
    </ClassDef>
    <ClassDef Name="HsProcedureDef">
      <Settings>
        <InHeritsFrom/>
        <UseCustomClass>false</UseCustomClass>
        <UseInterface>true</UseInterface>
        <UseStrict>true</UseStrict>
        <MakeList>true</MakeList>
        <UseEnumerator>true</UseEnumerator>
        <UseNestedClass>false</UseNestedClass>
        <TrackChange>false</TrackChange>
        <DataType>dsNone</DataType>
      </Settings>
      <Properies>
        <Property Name="ProcedureType" PropertyType="ptByte">
          <IsReadOnly>false</IsReadOnly>
          <IsDataAware>false</IsDataAware>
        </Property>
        <Property Name="ProcedureDef" PropertyType="ptString">
          <IsReadOnly>false</IsReadOnly>
          <IsDataAware>false</IsDataAware>
          <MaxLen>0</MaxLen>
        </Property>
        <Property Name="ProcedureName" PropertyType="ptString">
          <IsReadOnly>false</IsReadOnly>
          <IsDataAware>false</IsDataAware>
          <MaxLen>0</MaxLen>
        </Property>
        <Property Name="ProcedureParameters" PropertyType="ptString">
          <IsReadOnly>false</IsReadOnly>
          <IsDataAware>false</IsDataAware>
          <MaxLen>0</MaxLen>
        </Property>
        <Property Name="ResultType" PropertyType="ptByte">
          <IsReadOnly>false</IsReadOnly>
          <IsDataAware>false</IsDataAware>
        </Property>
        <Property Name="IsReintroduce" PropertyType="ptBoolean">
          <IsReadOnly>false</IsReadOnly>
          <IsDataAware>false</IsDataAware>
        </Property>
        <Property Name="IsVirtual" PropertyType="ptBoolean">
          <IsReadOnly>false</IsReadOnly>
          <IsDataAware>false</IsDataAware>
        </Property>
        <Property Name="IsAbstract" PropertyType="ptBoolean">
          <IsReadOnly>false</IsReadOnly>
          <IsDataAware>false</IsDataAware>
        </Property>
        <Property Name="IsOverRide" PropertyType="ptBoolean">
          <IsReadOnly>false</IsReadOnly>
          <IsDataAware>false</IsDataAware>
        </Property>
        <Property Name="IsOverLoad" PropertyType="ptBoolean">
          <IsReadOnly>false</IsReadOnly>
          <IsDataAware>false</IsDataAware>
        </Property>
        <Property Name="ProcedureScope" PropertyType="ptByte">
          <IsReadOnly>false</IsReadOnly>
          <IsDataAware>false</IsDataAware>
        </Property>
        <Property Name="ProcedureImpl" PropertyType="ptStringList">
          <IsReadOnly>true</IsReadOnly>
          <IsDataAware>false</IsDataAware>
        </Property>
      </Properies>
      <Procedures>
        <Procedure>
          <Parameters>Const AForClass : Boolean = False</Parameters>
          <ProcedureName>GetProcedureDefinition</ProcedureName>
          <ProcedureImpl>Begin
  If FResultType = rtNone Then
    Result := 'Procedure '
  Else
    Result := 'Function ';

  If Not AForClass Then
    Result := Result + 'T%ClassName%.';

  Result := Result + FProcedureName + '(' + FProcedureParameters + ')';

  If FResultType &lt;&gt; rtNone Then
    Result := Result + ' : ' + GetResultTypeStr(FResultType);

  If GetIsReIntroduce() Then
    Result := Result + '; ReIntroduce';

  If GetIsVirtual() Then
    Result := Result + '; Virtual';

  If GetIsAbstract() Then
    Result := Result + '; Abstract';

  If GetIsOverLoad() Then
    Result := Result + '; OverLoad';

  If GetIsOverRide() Then
    Result := Result + '; OverRide';

  Result := Result + ';';
End;
</ProcedureImpl>
          <ResultType>rtString</ResultType>
          <Scope>fsProtected</Scope>
          <IsVirtual>false</IsVirtual>
          <IsAbstract>false</IsAbstract>
          <IsOverRide>false</IsOverRide>
          <IsReIntroduce>false</IsReIntroduce>
          <IsOverLoad>false</IsOverLoad>
          <ShowInInterface>true</ShowInInterface>
        </Procedure>
      </Procedures>
    </ClassDef>
    <ClassDef Name="HsClassCodeGenerator">
      <Settings>
        <InHeritsFrom/>
        <UseCustomClass>false</UseCustomClass>
        <UseInterface>true</UseInterface>
        <UseStrict>true</UseStrict>
        <MakeList>true</MakeList>
        <UseEnumerator>true</UseEnumerator>
        <UseNestedClass>false</UseNestedClass>
        <TrackChange>false</TrackChange>
        <DataType>dsNone</DataType>
      </Settings>
      <Properies>
        <Property Name="ClsName" PropertyType="ptString">
          <IsReadOnly>false</IsReadOnly>
          <IsDataAware>false</IsDataAware>
          <MaxLen>0</MaxLen>
        </Property>
        <Property Name="InHeritsFrom" PropertyType="ptString">
          <IsReadOnly>false</IsReadOnly>
          <IsDataAware>false</IsDataAware>
          <MaxLen>0</MaxLen>
        </Property>
        <Property Name="UseCustomClass" PropertyType="ptBoolean">
          <IsReadOnly>false</IsReadOnly>
          <IsDataAware>false</IsDataAware>
        </Property>
        <Property Name="UseInterface" PropertyType="ptBoolean">
          <IsReadOnly>false</IsReadOnly>
          <IsDataAware>false</IsDataAware>
        </Property>
        <Property Name="UseStrict" PropertyType="ptBoolean">
          <IsReadOnly>false</IsReadOnly>
          <IsDataAware>false</IsDataAware>
        </Property>
        <Property Name="MakeList" PropertyType="ptBoolean">
          <IsReadOnly>false</IsReadOnly>
          <IsDataAware>false</IsDataAware>
        </Property>
        <Property Name="UseEnumerator" PropertyType="ptBoolean">
          <IsReadOnly>false</IsReadOnly>
          <IsDataAware>false</IsDataAware>
        </Property>
        <Property Name="UseNestedClass" PropertyType="ptBoolean">
          <IsReadOnly>false</IsReadOnly>
          <IsDataAware>false</IsDataAware>
        </Property>
        <Property Name="TrackChange" PropertyType="ptBoolean">
          <IsReadOnly>false</IsReadOnly>
          <IsDataAware>false</IsDataAware>
        </Property>
        <Property Name="DataType" PropertyType="ptByte">
          <IsReadOnly>false</IsReadOnly>
          <IsDataAware>false</IsDataAware>
        </Property>
        <Property Name="AdoQueryClassName" PropertyType="ptString">
          <IsReadOnly>false</IsReadOnly>
          <IsDataAware>false</IsDataAware>
          <MaxLen>0</MaxLen>
        </Property>
        <Property Name="TableName" PropertyType="ptString">
          <IsReadOnly>false</IsReadOnly>
          <IsDataAware>false</IsDataAware>
          <MaxLen>0</MaxLen>
        </Property>
        <Property Name="PropertyDefs" PropertyType="ptInterface">
          <IsReadOnly>true</IsReadOnly>
          <InterfaceName>IHsPropertyDefs</InterfaceName>
          <InterfaceImplementor>THsPropertyDefs</InterfaceImplementor>
          <IsDataAware>false</IsDataAware>
        </Property>
        <Property Name="ProcedureDefs" PropertyType="ptInterface">
          <IsReadOnly>true</IsReadOnly>
          <InterfaceName>IHsProcedureDefs</InterfaceName>
          <InterfaceImplementor>THsProcedureDefs</InterfaceImplementor>
          <IsDataAware>false</IsDataAware>
        </Property>
      </Properies>
      <Procedures>
        <Procedure>
          <Parameters>AList : TStringList</Parameters>
          <ProcedureName>GenerateInterfaceDef</ProcedureName>
          <ProcedureImpl>Const
  MagicGuid = 2383012921268594798;
Var lGuidRec : Packed Record
      Case Boolean Of
        True : (Guid : TGuid);
        False : (Int1, Int2 : Int64);
    End;
    X : Integer;
    lTmpList : TStringList;
Begin
  If FInHeritsFrom &lt;&gt; '' Then
    AList.Add('  I' + FClsName + ' = Interface(I' + Copy(FInHeritsFrom, 2, Length(FInHeritsFrom)) + ')')
  Else If FDataType = dsJSon Then
    AList.Add('  I' + FClsName + ' = Interface(ISuperObjectEx)')
  Else If FDataType = dsXML Then
    AList.Add('  I' + FClsName + ' = Interface(IXmlNodeEx)')
  Else
    AList.Add('  I' + FClsName + ' = Interface(IInterfaceEx)');

  CreateGUID(lGuidRec.Guid);
  lGuidRec.Int1 := MagicGuid;
  AList.Add('    [''' + GUIDToString(lGuidRec.Guid) + ''']');

  For X := 0 To FProcedureDefs.Count - 1 Do
    AList.Add('    ' + FProcedureDefs[X].GetProcedureDefinition(True));
  If FProcedureDefs.Count &gt; 0 Then
    AList.Add('');

  For X := 0 To FPropertyDefs.Count - 1 Do
    AList.Add(FPropertyDefs[X].GetPropertyFunctions(True, True, False, False, 2));

  lTmpList := TStringList.Create();
  Try
    For X := 0 To FPropertyDefs.Count - 1 Do
      lTmpList.Add(FPropertyDefs[X].GetPropertyDefinition(True, True));
    AlignProperties(lTmpList);
    For X := 0 To lTmpList.Count - 1 Do
      AList.Add(lTmpList[X]);
    Finally
      lTmpList.Free();
  End;
  AList.Add('');
  AList.Add('  End;');
  AList.Add('');

  If FMakeList Then
  Begin
    If FUseEnumerator And (FDataType = dsNone) Then
    Begin
      CreateGUID(lGuidRec.Guid);
      lGuidRec.Int1 := MagicGuid;

      AList.Add('  I' + FClsName + 'Enumerator = Interface(IInterfaceExEnumerator)');
      AList.Add('    [''' + GUIDToString(lGuidRec.Guid) + ''']');
      AList.Add('    Function GetCurrent() : I' + FClsName + ';');
      AList.Add('    Property Current : I' + FClsName + ' Read GetCurrent;');
      AList.Add('');
      AList.Add('  End;');
      AList.Add('');
    End;

    If FDataType = dsJSon Then
      AList.Add('  I' + FClsName + 's = Interface(ISuperObjectExList)')
    Else If FDataType = dsXML Then
      AList.Add('  I' + FClsName + 's = Interface(IXmlNodeCollectionEx)')
    Else
      AList.Add('  I' + FClsName + 's = Interface(IInterfaceListEx)');

    CreateGUID(lGuidRec.Guid);
    lGuidRec.Int1 := MagicGuid;
    AList.Add('    [''' + GUIDToString(lGuidRec.Guid) + ''']');

    If (FDataType = dsJSon) Then
    Begin
      AList.Add('    Function GetItem(Const Index : Integer) : I' + FClsName + ';');
      AList.Add('');
      AList.Add('    Function Add() : I' + FClsName + '; OverLoad;');
      AList.Add('    Function Add(Const AItem : I' + FClsName + ') : Integer; OverLoad;');
      AList.Add('');
      AList.Add('    Property Items[Const Index: Integer] : I' + FClsName + ' Read MyGetItem; Default;');
    End
    Else If FDataType = dsXML Then
    Begin
      AList.Add('    Function GetItem(Const Index : Integer) : I' + FClsName + ';');
      AList.Add('');
      AList.Add('    Function Add() : I' + FClsName + ';');
      AList.Add('    Function Insert(Const Index: Integer) : I' + FClsName + ';');
      AList.Add('');
      AList.Add('    Property Items[Const Index: Integer] : I' + FClsName + ' Read GetItem; Default;');
    End
    Else
    Begin
      If FUseEnumerator Then
      Begin
        AList.Add('    Function  GetEnumerator() : I' + FClsName + 'Enumerator;');
        AList.Add('');
      End;

      AList.Add('    Function  Get(Index : Integer) : I' + FClsName + ';');
      AList.Add('    Procedure Put(Index : Integer; Const Item : I' + FClsName + ');');
      AList.Add('');
      AList.Add('    Function Add() : I' + FClsName + '; OverLoad;');
      AList.Add('    Function Add(Const AItem : I' + FClsName + ') : Integer; OverLoad;');
      AList.Add('');
      AList.Add('    Property Items[Index : Integer] : I' + FClsName + ' Read Get Write Put; Default;');
    End;
    AList.Add('');
    AList.Add('  End;');
    AList.Add('');
  End;
End;
</ProcedureImpl>
          <ResultType>rtNone</ResultType>
          <Scope>fsProtected</Scope>
          <IsVirtual>false</IsVirtual>
          <IsAbstract>false</IsAbstract>
          <IsOverRide>false</IsOverRide>
          <IsReIntroduce>false</IsReIntroduce>
          <IsOverLoad>false</IsOverLoad>
          <ShowInInterface>true</ShowInInterface>
        </Procedure>
        <Procedure>
          <Parameters>AList : TStringList</Parameters>
          <ProcedureName>GenerateClassDef</ProcedureName>
          <ProcedureImpl>Var lTmpList  : TStringList;
    X         : Integer;
    lPrivFunc ,
    lProtFunc ,
    lPublFunc : IHsProcedureDefs;
Begin
  lPrivFunc := THsProcedureDefs.Create();
  lProtFunc := THsProcedureDefs.Create();
  lPublFunc := THsProcedureDefs.Create();

  For X := 0 To FProcedureDefs.Count - 1 Do
    If FProcedureDefs[X].ProcedureScope = fsPrivate Then
      lPrivFunc.Add(FProcedureDefs[X])
    Else If FProcedureDefs[X].ProcedureScope = fsProtected Then
      lProtFunc.Add(FProcedureDefs[X])
    Else If FProcedureDefs[X].ProcedureScope = fsPublic Then
      lPublFunc.Add(FProcedureDefs[X]);

  If FMakeList And FUseNestedClass And (FDataType = dsNone) Then
  Begin
    lTmpList := TStringList.Create();
    Try
      AList.Add('  T' + FClsName + 'List = Class(TInterfaceListEx, I' + FClsName + 's)');
      If FUseStrict Then
        AList.Add('  Strict Private Type')
      Else
        AList.Add('  Private Type');
  (**)
      If FUseEnumerator Then
      Begin
        AList.Add('    T' + FClsName + 'Enumerator = Class(TInterfaceExEnumerator, I' + FClsName + 'Enumerator)');
        AList.Add('    Protected');
        AList.Add('      Function GetCurrent() : I' + FClsName + '; OverLoad;');
        AList.Add('');
        AList.Add('    End;');
        AList.Add('');
      End;

      AList.Add('    T' + FClsName + 'Item = Class(TInterfacedObjectEx, I' + FClsName + ')');
      If FUseStrict Then
        AList.Add('    Strict Private')
      Else
        AList.Add('    Private');

      lTmpList.Clear();

      If FTrackChange Then
        lTmpList.Add('      FDataState:TDataState;');

      For X := 0 To FPropertyDefs.Count - 1 Do
        lTmpList.Add('      ' + FPropertyDefs.Items[X].GetVariableDefinition());

      If lTmpList.Count &gt; 0 Then
      Begin
        AlignVariables(lTmpList);

        For X := 0 To lTmpList.Count - 1 Do
          AList.Add(lTmpList[X]);

        AList.Add('');
      End;

      AList.Add('    Protected');
  //--&gt;
      For X := 0 To FPropertyDefs.Count - 1 Do
        AList.Add(FPropertyDefs.Items[X].GetPropertyFunctions(True, True, False, False, 3));

      If FTrackChange Then
      Begin
        AList.Add('      Procedure Changed();');
        AList.Add('      Function  GetModified() : Boolean;');
        AList.Add('');
      End;

      AList.Add('      Procedure Clear();');
      AList.Add('      Procedure Assign(ASource : TObject); ReIntroduce; Virtual;');

      If FPropertyDefs.HaveConstructor Or FPropertyDefs.HaveDestructor Then
      Begin
        AList.Add('');
        AList.Add('    Public');
      End;

      If FPropertyDefs.HaveConstructor Then
      Begin
        AList.Add('      Procedure AfterConstruction(); OverRide;');
        
        If Not FPropertyDefs.HaveDestructor Then
          AList.Add('');
      End;

      If FPropertyDefs.HaveDestructor And Not (FDataType In [dsXML]) Then
      Begin
        AList.Add('      Procedure BeforeDestruction(); OverRide;');
        AList.Add('');
      End;

      AList.Add('    End;');
      AList.Add('');
  (**)
      AList.Add('  Protected');
      AList.Add('    Function GetItemClass() : TInterfacedObjectExClass; OverRide;');
      AList.Add('    Function GetEnumerator() : I' + FClsName + 'Enumerator; OverLoad;');
      AList.Add('');
      AList.Add('    Function  Get(Index : Integer) : I' + FClsName + '; OverLoad;');
      AList.Add('    Procedure Put(Index : Integer; Const Item : I' + FClsName + '); OverLoad;');
      AList.Add('');
      AList.Add('    Function Add() : I' + FClsName + '; OverLoad;');
      AList.Add('    Function Add(Const AItem : I' + FClsName + ') : Integer; OverLoad;');
      AList.Add('');
      AList.Add('  End;');

      Finally
        lTmpList.Free();
    End;
  End
  Else
  Begin
    lTmpList := TStringList.Create();
    Try
      If FUseInterface Or (FDataType In [dsJSon, dsXML]) Then
      Begin
        If FInHeritsFrom &lt;&gt; '' Then
        Begin
          If FUseCustomClass Then
            AList.Add('  TCustom' + FClsName + ' = Class(' + FInHeritsFrom + ', I' + FClsName + ')')
          Else
            AList.Add('  T' + FClsName + ' = Class(' + FInHeritsFrom + ', I' + FClsName + ')')
        End
        Else Case FDataType Of
          dsJSon :
          Begin
            If FUseCustomClass Then
              AList.Add('  TCustom' + FClsName + ' = Class(TSuperObjectEx, I' + FClsName + ')')
            Else
              AList.Add('  T' + FClsName + ' = Class(TSuperObjectEx, I' + FClsName + ')');
          End;

          dsXML :
          Begin
            AList.Add('  T' + FClsName + ' = Class(TXmlNodeEx, I' + FClsName + ')');
          End;

          Else
            If FUseCustomClass Then
              AList.Add('  TCustom' + FClsName + ' = Class(TInterfacedObjectEx, I' + FClsName + ')')
            Else
              AList.Add('  T' + FClsName + ' = Class(TInterfacedObjectEx, I' + FClsName + ')');
        End;
      End
      Else
      Begin
        If FUseCustomClass Then
          AList.Add('  TCustom' + FClsName + ' = Class(TPersistent)')
        Else
          AList.Add('  T' + FClsName + ' = Class(TPersistent)');
      End;

      //Variables
      If Not (FDataType In [dsJSon, dsXML]) Then
      Begin
        If FUseStrict Then
          AList.Add('  Strict Private')
        Else
          AList.Add('  Private');

        lTmpList.Clear();
        For X := 0 To FPropertyDefs.Count - 1 Do
          lTmpList.Add('    ' + FPropertyDefs.Items[X].GetVariableDefinition());
      End;

      If FTrackChange Then
        lTmpList.Add('    FDataState:TDataState;');

      AlignVariables(lTmpList);
      For X := 0 To lTmpList.Count - 1 Do
        AList.Add(lTmpList[X]);

      For X := 0 To lPrivFunc.Count - 1 Do
        AList.Add(PadL('', 4) + lPrivFunc[X].GetProcedureDefinition(True));

      If Not (FDataType In [dsJSon, dsXML]) Or FTrackChange Then
        AList.Add('');
      If Not FUseInterface And FUseStrict Then
        AList.Add('  Strict Protected')
      Else
        AList.Add('  Protected');

      For X := 0 To FPropertyDefs.Count - 1 Do
      Begin
        If Trim(FPropertyDefs.Items[X].GetPropertyFunctions(
          FUseInterface Or (FDataType In [dsJSon, dsXML]),
          FUseInterface Or FTrackChange Or (FDataType In [dsJSon, dsXML]),
          True, False, 2)) &lt;&gt; '' Then
          AList.Add(FPropertyDefs.Items[X].GetPropertyFunctions(
            FUseInterface Or (FDataType In [dsJSon, dsXML]),
            FUseInterface Or FTrackChange Or (FDataType In [dsJSon, dsXML]),
            True, False, 2));
      End;

      If FTrackChange Then
      Begin
        AList.Add('    Procedure Changed(); Virtual;');
        AList.Add('    Function  GetModified() : Boolean;');
      End;
      AList.Add('    Procedure Clear();');
      AList.Add('');

      For X := 0 To lProtFunc.Count - 1 Do
        AList.Add(PadL('', 4) + lProtFunc[X].GetProcedureDefinition(True));

      If lProtFunc.Count &gt; 0 Then
        AList.Add('');
      
      //If Not (FDataType In [dsJSon, dsXML]) Then
      Begin
        If Not FUseCustomClass Then
          AList.Add('  Published');

        lTmpList.Clear();
        For X := 0 To FPropertyDefs.Count - 1 Do
          lTmpList.Add('    ' + FPropertyDefs.Items[X].GetPropertyDefinition(
            FUseInterface Or (FDataType In [dsJSon, dsXML]),
            FUseInterface Or FTrackChange Or (FDataType In [dsJSon, dsXML])));
      End;

      AlignProperties(lTmpList);
      For X := 0 To lTmpList.Count - 1 Do
        AList.Add(lTmpList[X]);

      AList.Add('');
      AList.Add('  Public');
      If FDataType = dsMSSql Then
      Begin
        AList.Add('    Procedure New();');
        AList.Add(GetLoadParamType('    Procedure Load(AId : %DataType%);'));
        AList.Add('    Procedure Save();');
        AList.Add('    Procedure Delete();');
        AList.Add('    Procedure CreateTable();');
      End;
      AList.Add('    Procedure Assign(ASource : TObject); ReIntroduce; Virtual;');
      AList.Add('');

      For X := 0 To lPublFunc.Count - 1 Do
        AList.Add(PadL('', 4) + lPublFunc[X].GetProcedureDefinition(True));

      If lPublFunc.Count &gt; 0 Then
        AList.Add('');

      If FPropertyDefs.HaveConstructor Then
      Begin
        If FDataType In [dsJSon, dsXML] Then
          AList.Add('    Procedure AfterConstruction(); OverRide;')
        Else
          AList.Add('    Constructor Create(); ReIntroduce; Virtual;');

        AList.Add('');
      End;

      If FPropertyDefs.HaveDestructor And Not (FDataType In [dsXML]) Then
      Begin
        AList.Add('    Destructor Destroy(); OverRide;');
        AList.Add('');
      End;

      AList.Add('  End;');

      If FUseCustomClass {And Not (FDataType In [dsJSon, dsXML])} Then
      Begin
        AList.Add('');

        AList.Add('  T' + FClsName + ' = Class(TCustom' + FClsName + ')');
        AList.Add('  Published');
        For X := 0 To FPropertyDefs.Count - 1 Do
          AList.Add('    Property ' + FPropertyDefs[X].PropertyName + ';');
        AList.Add('');
        AList.Add('  End;');
      End;

      {$Region ' Lists '}
      If FMakeList Then
      Begin
        If FUseEnumerator And (FDataType = dsNone) Then
        Begin
          AList.Add('');
          AList.Add('  T' + FClsName + 'Enumerator = Class(TInterfaceExEnumerator, I' + FClsName + 'Enumerator)');
          AList.Add('  Protected');
          AList.Add('    Function GetCurrent() : I' + FClsName + '; OverLoad;');
          AList.Add('');
          AList.Add('  End;');
        End;

        AList.Add('');

        If FDataType = dsJSon Then
        Begin
          AList.Add('  T' + FClsName + 's = Class(TSuperObjectExList, I' + FClsName + 's)');
          AList.Add('  Protected');
          AList.Add('    Function GetItemClass() : TSuperObjectExClass; OverRide;');
          AList.Add('    Function GetItem(Const Index : Integer) : I' + FClsName + '; OverLoad;');
          AList.Add('');
          AList.Add('  Public');
          AList.Add('    Function Add() : I' + FClsName + '; OverLoad;');
          AList.Add('    Function Add(Const AItem : I' + FClsName + ') : Integer; OverLoad;');
          AList.Add('');
          AList.Add('    Property Items[Const Index: Integer] : I' + FClsName + ' Read MyGetItem; Default;');
          AList.Add('');
          AList.Add('  End;');
        End
        Else If FDataType = dsXML Then
        Begin
          AList.Add('  T' + FClsName + 's = Class(TXMLNodeCollectionEx, I' + FClsName + 's)');
          AList.Add('  Protected');
          AList.Add('    Function GetItem(Const Index : Integer) : I' + FClsName + ';');
          AList.Add('');
          AList.Add('    Function Add() : I' + FClsName + ';');
          AList.Add('    Function Insert(Const Index : Integer) : I' + FClsName + ';');
          AList.Add('');
          AList.Add('  Public');
          AList.Add('    Procedure AfterConstruction(); OverRide;');
          AList.Add('');
          AList.Add('  End;');
        End
        Else If FUseInterface Then
        Begin
          AList.Add('  T' + FClsName + 's = Class(TInterfaceListEx, I' + FClsName + 's)');
          AList.Add('  Protected');
          AList.Add('    Function GetItemClass() : TInterfacedObjectExClass; OverRide;');
          If FUseEnumerator Then
            AList.Add('    Function GetEnumerator() : I' + FClsName + 'Enumerator; OverLoad;');
          AList.Add('');
          AList.Add('    Function  Get(Index : Integer) : I' + FClsName + '; OverLoad;');
          AList.Add('    Procedure Put(Index : Integer; Const Item : I' + FClsName + '); OverLoad;');
          AList.Add('');
          AList.Add('    Function Add() : I' + FClsName + '; OverLoad;');
          AList.Add('    Function Add(Const AItem : I' + FClsName + ') : Integer; OverLoad;');
          AList.Add('');
          AList.Add('  End;');
        End
        Else
        Begin
          AList.Add('  T' + FClsName + 's = Class(TObjectList)');
          AList.Add('  Protected');
          AList.Add('    Function  GetItem(Index : Integer) : T' + FClsName + ';');
          AList.Add('    Procedure SetItem(Index : Integer; Const Item: T' + FClsName + ');');
          AList.Add('');
          AList.Add('  Public');
          AList.Add('    Property Items[Index : Integer] : T' + FClsName + ' Read GetItem Write SetItem; Default;');
          AList.Add('');
          AList.Add('  End;');
        End;
      End;
      {$EndRegion}

      Finally
        lTmpList.Free();

        lPrivFunc := Nil;
        lProtFunc := Nil;
        lPublFunc := Nil;
    End;
  End;
End;
</ProcedureImpl>
          <ResultType>rtNone</ResultType>
          <Scope>fsProtected</Scope>
          <IsVirtual>false</IsVirtual>
          <IsAbstract>false</IsAbstract>
          <IsOverRide>false</IsOverRide>
          <IsReIntroduce>false</IsReIntroduce>
          <IsOverLoad>false</IsOverLoad>
          <ShowInInterface>true</ShowInInterface>
        </Procedure>
        <Procedure>
          <Parameters>AList : TStringList</Parameters>
          <ProcedureName>GenerateClassImpl</ProcedureName>
          <ProcedureImpl>Var lClsName : String;
    lTmpList : TStringList;
    X        : Integer;
Begin
  lTmpList := TStringList.Create();
  Try
    If FMakeList And FUseNestedClass Then
    Begin
      FUseCustomClass := False;
      FUseInterface   := True;
      FDataType       := dsNone;
    End;

    Begin
      If FUseCustomClass Then
        lClsName := 'Custom';
      lClsName := lClsName + FClsName;

      {$Region ' Constructor / Destructor '}
      If FPropertyDefs.HaveConstructor Then
      Begin
        If (FDataType In [dsJSon, dsXML]) Or FUseNestedClass Then
        Begin
          If FUseNestedClass Then
            AList.Add('Procedure T' + FClsName + 'List.T' + FClsName + 'Item.AfterConstruction();')
          Else
            AList.Add('Procedure T' + lClsName + '.AfterConstruction();');
          AList.Add('Begin');
          AList.Add('  InHerited AfterConstruction();');
        End
        Else
        Begin
          AList.Add('Constructor T' + lClsName + '.Create();');
          AList.Add('Begin');
          AList.Add('  InHerited Create();');
        End;

        AList.Add('');
        For X := 0 To FPropertyDefs.Count - 1 Do
          Case FPropertyDefs[X].PropertyType Of
            ptObject :
              lTmpList.Add('  F' +
                FPropertyDefs[X].PropertyName + ':=' +
                FPropertyDefs[X].PropertyClass + '.Create();');
            ptInterface :
            Begin
              If FDataType = dsJSon Then
              Begin
                lTmpList.Add('  O[''' +
                  FPropertyDefs[X].PropertyName + ''']:=' +
                  FPropertyDefs[X].InterfaceImplementor +
                  '.Create() As ' + FPropertyDefs[X].InterfaceName + ';');
              End
              Else If FDataType &lt;&gt; dsXML Then
                lTmpList.Add('  F' +
                  FPropertyDefs[X].PropertyName + ':=' +
                  FPropertyDefs[X].InterfaceImplementor + '.Create();');
            End;
            ptStringList :
              lTmpList.Add('  F' + FPropertyDefs[X].PropertyName + ':=TStringList.Create();');
          End;

        AlignVariableAssign(lTmpList);
        For X := 0 To lTmpList.Count - 1 Do
          AList.Add(lTmpList[X]);

        For X := 0 To FPropertyDefs.Count - 1 Do
          Case FPropertyDefs[X].PropertyType Of
            ptObject : ;

            ptInterface :
            Begin
              If FDataType In [dsXML, dsJSon] Then
                AList.Add('  RegisterChildNode(''' + FPropertyDefs[X].PropertyName + ''', ' + FPropertyDefs[X].InterfaceImplementor + ');');
            End;
          End;
        AList.Add('End;');
        AList.Add('');
      End;

      If FPropertyDefs.HaveDestructor And Not (FDataType In [dsXML]) Then
      Begin
        If FUseNestedClass Then
          AList.Add('Procedure T' + FClsName + 'List.T' + FClsName + 'Item.BeforeDestruction();')
        Else
          AList.Add('Destructor T' + lClsName + '.Destroy();');
        AList.Add('Begin');
        For X := 0 To FPropertyDefs.Count - 1 Do
          Case FPropertyDefs[X].PropertyType Of
            ptObject, ptStringList :
            Begin
              AList.Add('  If Assigned(F' + FPropertyDefs[X].PropertyName + ') Then');
              AList.Add('    FreeAndNil(F' + FPropertyDefs[X].PropertyName + ');');
            End;
            ptInterface :
            Begin
              Case FDataType Of
                dsJSon :
                Begin
                  AList.Add('  O[''' +
                    FPropertyDefs[X].PropertyName + '''] := Nil;');
                End
                Else
                  AList.Add('  F' +
                    FPropertyDefs[X].PropertyName + ' := Nil;');
              End;
            End;
          End;
        AList.Add('');

        If FUseNestedClass Then
          AList.Add('  InHerited BeforeDestruction();')
        Else
          AList.Add('  InHerited Destroy();');
        AList.Add('End;');
        AList.Add('');
      End;
      {$EndRegion}

      If FTrackChange Then
      Begin
        If FUseNestedClass Then
          AList.Add('Procedure T' + FClsName + 'List.T' + FClsName + 'Item.Changed();')
        Else
          AList.Add('Procedure T' + lClsName + '.Changed();');

        AList.Add('Begin');
        AList.Add('  Case FDataState Of');
        AList.Add('    edsBrowse : FDataState := edsModified;');
        AList.Add('  End;');
        AList.Add('End;');
        AList.Add('');

        If FUseNestedClass Then
          AList.Add('Function T' + FClsName + 'List.T' + FClsName + 'Item.GetModified() : Boolean;')
        Else
          AList.Add('Function T' + lClsName + '.GetModified() : Boolean;');
        AList.Add('Begin');
        AList.Add('  Result := FDataState &lt;&gt; edsBrowse;');
        AList.Add('End;');
        AList.Add('');
      End;

      lTmpList.Clear();
      If FUseNestedClass Then
        AList.Add('Procedure T' + FClsName + 'List.T' + FClsName + 'Item.Clear();')
      Else
        AList.Add('Procedure T' + lClsName + '.Clear();');

      AList.Add('Begin');
      If FDataType = dsJSon Then
      Begin
        For X := 0 To FPropertyDefs.Count - 1 Do
          Case FPropertyDefs[X].PropertyType Of
            ptByte, ptInteger, ptSingle : lTmpList.Add('I[''' + FPropertyDefs[X].PropertyName + ''']:=0;');
            ptDouble, ptExtended : lTmpList.Add('D[''' + FPropertyDefs[X].PropertyName + ''']:=0;');
            ptCurrency : lTmpList.Add('C[''' + FPropertyDefs[X].PropertyName + ''']:=0;');
            ptDate, ptTime, ptDateTime : ;
            ptChar, ptString, ptWideString : lTmpList.Add('S[''' + FPropertyDefs[X].PropertyName + ''']:='''';');
            ptBoolean : lTmpList.Add('B[''' + FPropertyDefs[X].PropertyName + ''']:=False;');
            ptObject :
              lTmpList.Add('O[''' + FPropertyDefs[X].PropertyName + ''']:=' +
                FPropertyDefs[X].PropertyClass + '.Create();');
            ptInterface :
              lTmpList.Add('O[''' + FPropertyDefs[X].PropertyName + ''']:=' +
                FPropertyDefs[X].InterfaceImplementor + '.Create() As ' +
                FPropertyDefs[X].InterfaceName + ';'
              );
          End;
      End
      Else If FDataType = dsXML Then
      Begin
        For X := 0 To FPropertyDefs.Count - 1 Do
          lTmpList.Add('ChildNodes[''' + FPropertyDefs[X].PropertyName + '''].NodeValue:=Null;');
      End
      Else
      Begin
        For X := 0 To FPropertyDefs.Count - 1 Do
          Case FPropertyDefs[X].PropertyType Of
            ptByte, ptInteger, ptSingle,
            ptDouble, ptExtended, ptCurrency,
            ptDate, ptTime, ptDateTime,
            ptWord, ptDWord, ptQWord : lTmpList.Add('F' + FPropertyDefs[X].PropertyName + ':=0;');
            ptChar : lTmpList.Add('F' + FPropertyDefs[X].PropertyName + ':=#0;');
            ptString, ptWideString : lTmpList.Add('F' + FPropertyDefs[X].PropertyName + ':='''';');
            ptBoolean : lTmpList.Add('F' + FPropertyDefs[X].PropertyName + ':=False;');
          End;
      End;

      AlignVariableAssign(lTmpList);
      For X := 0 To lTmpList.Count - 1 Do
        AList.Add(lTmpList[X]);

      AList.Add('End;');
      AList.Add('');
    
      {$Region ' MsSql Procs '}
      If FDataType In [dsMSSql] Then
      Begin
        AList.Add('Procedure T' + lClsName + '.New();');
        AList.Add('Begin');
        AList.Add('  Clear();');
        If FTrackChange Then
          AList.Add('  FDataState := edsAdded;');
        AList.Add('End;');
        AList.Add('');

        For X := 0 To FPropertyDefs.Count - 1 Do
          If FPropertyDefs[X].IsId Then
          Begin
            Case FPropertyDefs[X].PropertyType Of
              ptInteger : AList.Add('Procedure T' + lClsName + '.Load(AId : Integer);');
              ptString  : AList.Add('Procedure T' + lClsName + '.Load(AId : String);');
            End;

            Break;
          End;

  //      AList.Add(GetLoadParamType('Procedure T' + lClsName + '.Load(AId : %DataType%);'));
        AList.Add(GetLoadParamType('Procedure T' + lClsName + '.Load(AId : %DataType%);'));
        AList.Add('Begin');
        lTmpList.Clear();
        If FDataType = dsMSSql Then
        Begin
          GenerateMSSqlLoadCode(lTmpList);
          For X := 0 To lTmpList.Count - 1 Do
            AList.Add(lTmpList[X]);
        End;
        AList.Add('End;');
        AList.Add('');

        AList.Add('Procedure T' + lClsName + '.Save();');
        AList.Add('Begin');
        lTmpList.Clear();
        If FDataType = dsMSSql Then
        Begin
          GenerateMSSqlSaveCode(lTmpList);
          For X := 0 To lTmpList.Count - 1 Do
            AList.Add(lTmpList[X]);
        End;
        AList.Add('End;');
        AList.Add('');

        AList.Add('Procedure T' + lClsName + '.Delete();');
        AList.Add('Begin');
        AList.Add('  FDataState := edsDeleted;');
        AList.Add('End;');
        AList.Add('');

        AList.Add('Procedure T' + lClsName + '.CreateTable();');
        AList.Add('Begin');
        lTmpList.Clear();
        If FDataType = dsMSSql Then
        Begin
          GenerateMSSqlCreateTableCode(lTmpList);
          For X := 0 To lTmpList.Count - 1 Do
            AList.Add(lTmpList[X]);
        End;
        AList.Add('End;');
        AList.Add('');
      End;
      {$EndRegion}

      If FUseNestedClass Then
        AList.Add('Procedure T' + FClsName + 'List.T' + FClsName + 'Item.Assign(ASource : TObject);')
      Else
        AList.Add('Procedure T' + lClsName + '.Assign(ASource : TObject);');

      lTmpList.Clear();
      If FDataType In [dsJSon] Then
      Begin
        lTmpList.Add('Var lSrc:T' + lClsName + ';');
      End
      Else
      Begin
        lTmpList.Add('Var lSrc:T' + lClsName + ';');
        If FDataType = dsMSSql Then
          lTmpList.Add('    lFields:TFields;');
      End;

      AlignVariables(lTmpList);
      For X := 0 To lTmpList.Count - 1 Do
        AList.Add(lTmpList[X]);

      AList.Add('Begin');
      AList.Add('  If ASource Is T' + lClsName + ' Then');
      AList.Add('  Begin');
      AList.Add('    lSrc := T' + lClsName + '(ASource);');
      AList.Add('');

      If FDataType = dsJSon Then
      Begin
        lTmpList.Clear();
        For X := 0 To FPropertyDefs.Count - 1 Do
          Case FPropertyDefs[X].PropertyType Of
            ptByte, ptInteger, ptSingle : lTmpList.Add('I[''' + FPropertyDefs[X].PropertyName + ''']:=lSrc.' + FPropertyDefs[X].PropertyName + ';');
            ptDouble, ptExtended : lTmpList.Add('D[''' + FPropertyDefs[X].PropertyName + ''']:=lSrc.' + FPropertyDefs[X].PropertyName + ';');
            ptCurrency : lTmpList.Add('C[''' + FPropertyDefs[X].PropertyName + ''']:=lSrc.' + FPropertyDefs[X].PropertyName + ';');
            ptDate, ptTime, ptDateTime : ;
            ptChar, ptString, ptWideString : lTmpList.Add('S[''' + FPropertyDefs[X].PropertyName + ''']:=lSrc.' + FPropertyDefs[X].PropertyName + ';');
            ptBoolean : lTmpList.Add('B[''' + FPropertyDefs[X].PropertyName + ''']:=lSrc.' + FPropertyDefs[X].PropertyName + ';');
          End;
      End
      Else If FDataType = dsXML Then
      Begin
        lTmpList.Clear();
        For X := 0 To FPropertyDefs.Count - 1 Do
          lTmpList.Add('ChildNodes[''' + FPropertyDefs[X].PropertyName + '''].NodeValue:=lSrc.' + FPropertyDefs[X].PropertyName + ';');
      End
      Else
      Begin
        lTmpList.Clear();
        For X := 0 To FPropertyDefs.Count - 1 Do
          lTmpList.Add('F' + FPropertyDefs[X].PropertyName + ':=lSrc.' + FPropertyDefs[X].PropertyName + ';');
      End;

      AlignVariableAssign(lTmpList);
      For X := 0 To lTmpList.Count - 1 Do
        AList.Add('  ' + lTmpList[X]);
      AList.Add('  End');

      If FDataType = dsMSSql Then
      Begin
        AList.Add('  Else If ASource Is TFields Then');
        AList.Add('  Begin');
        AList.Add('    lFields := TFields(ASource);');
        AList.Add('');
        lTmpList.Clear();
        For X := 0 To FPropertyDefs.Count - 1 Do
          If FPropertyDefs[X].IsDataAware Then
            lTmpList.Add( 'F' + FPropertyDefs[X].PropertyName +
                          ':=lFields.FieldByName(''' +
                          FPropertyDefs[X].FieldName + ''').' +
                          GetFieldAssignType(FPropertyDefs[X].PropertyType) + ';');

        AlignVariableAssign(lTmpList);
        For X := 0 To lTmpList.Count - 1 Do
          AList.Add('  ' + lTmpList[X]);
        AList.Add('  End');
      End;
      AList.Add('  Else'); //EConvertError -&gt; SysUtils, SAssignError -&gt; RTLConst
      AList.Add('    Raise EConvertError.CreateResFmt(@SAssignError, [ASource.ClassName, ClassName]);');
      AList.Add('End;');
      AList.Add('');

      For X := 0 To FProcedureDefs.Count - 1 Do
      Begin
        If FUseNestedClass Then
          AList.Add(StringReplace(FProcedureDefs[X].GetProcedureDefinition(False), '%ClassName%', 'T' + FClsName + 'List.T' + FClsName + 'Item', [rfReplaceAll, rfIgnoreCase]))
        Else
          AList.Add(StringReplace(FProcedureDefs[X].GetProcedureDefinition(False), '%ClassName%', lClsName, [rfReplaceAll, rfIgnoreCase]));
        AList.Add(FProcedureDefs[X].ProcedureImpl.Text);
      End;

      lTmpList.Clear();
      For X := 0 To FPropertyDefs.Count - 1 Do
        If Trim(FPropertyDefs.Items[X].GetPropertyFunctionImplementation(
          FUseInterface Or (FDataType In [dsJSon, dsXml]),
          FUseInterface Or FTrackChange Or (FDataType In [dsJSon, dsXml]),
          FTrackChange, FDataType)) &lt;&gt; '' Then
          If FUseNestedClass Then
            lTmpList.Add(StringReplace(FPropertyDefs.Items[X].GetPropertyFunctionImplementation(
              FUseInterface Or (FDataType In [dsJSon, dsXml]),
              FUseInterface Or FTrackChange Or (FDataType In [dsJSon, dsXml]),
              FTrackChange, FDataType), '%ClassName%', FClsName + 'List.T' + FClsName + 'Item', [rfReplaceAll, rfIgnoreCase]))
          Else
            lTmpList.Add(StringReplace(FPropertyDefs.Items[X].GetPropertyFunctionImplementation(
              FUseInterface Or (FDataType In [dsJSon, dsXml]),
              FUseInterface Or FTrackChange Or (FDataType In [dsJSon, dsXml]),
              FTrackChange, FDataType), '%ClassName%', lClsName, [rfReplaceAll, rfIgnoreCase]));

      //AddFormat
      For X := 0 To lTmpList.Count - 1 Do
        AList.Add(lTmpList[X]);

      {$Region ' Lists '}
      If FMakeList Then
      Begin
        If FDataType = dsJSon Then
        Begin
          AList.Add('Function T' + FClsName + 's.Add() : I' + FClsName + ';');
          AList.Add('Begin');
          AList.Add('  Result := T' + FClsName + '.Create(stObject);');
          AList.Add('  InHerited Add(Result);');
          AList.Add('End;');
          AList.Add('');
          AList.Add('Function T' + FClsName + 's.Add(Const AItem : I' + FClsName + ') : Integer;');
          AList.Add('Begin');
          AList.Add('  Result := InHerited Add(AItem);');
          AList.Add('End;');
          AList.Add('');
          AList.Add('Function T' + FClsName + 's.GetItemClass() : TSuperObjectExClass;');
          AList.Add('Begin');
          AList.Add('  Result := T' + FClsName + ';');
          AList.Add('End;');
          AList.Add('');
          AList.Add('Function T' + FClsName + 's.GetItem(Const Index : Integer) : I' + FClsName + ';');
          AList.Add('Begin');
          AList.Add('  Result := InHerited Items[Index] As I' + FClsName + ';');
          AList.Add('End;');
        End
        Else If FDataType = dsXML Then
        Begin
          AList.Add('Procedure T' + FClsName + 's.AfterConstruction();');
          AList.Add('Begin');
          AList.Add('  RegisterChildNode(''' + FClsName + ''', T' + FClsName + ');');
          AList.Add('  ItemTag       := ''' + FClsName + ''';');
          AList.Add('  ItemInterface := I' + FClsName + ';');
          AList.Add('');
          AList.Add('  InHerited AfterConstruction();');
          AList.Add('End;');
          AList.Add('');
          AList.Add('Function T' + FClsName + 's.GetItem(Const Index : Integer) : I' + FClsName + ';');
          AList.Add('Begin');
          AList.Add('  Result := List[Index] As I' + FClsName  + ';');
          AList.Add('End;');
          AList.Add('');
          AList.Add('Function T' + FClsName + 's.Add() : I' + FClsName + ';');
          AList.Add('Begin');
          AList.Add('  Result := AddItem(-1) As I' + FClsName + ';');
          AList.Add('End;');
          AList.Add('');
          AList.Add('Function T' + FClsName + 's.Insert(Const Index : Integer) : I' + FClsName + ';');
          AList.Add('Begin');
          AList.Add('  Result := AddItem(Index) As I' + FClsName + ';');
          AList.Add('End;');
        End
        Else If FUseInterface Then
        Begin
          If FUseEnumerator Then
          Begin
            If FUseNestedClass Then
              AList.Add('Function T' + FClsName + 'List.T' + FClsName + 'Enumerator.GetCurrent() : I' + FClsName + ';')
            Else
              AList.Add('Function T' + FClsName + 'Enumerator.GetCurrent() : I' + FClsName + ';');
            AList.Add('Begin');
            AList.Add('  Result := InHerited Current As I' + FClsName + ';');
            AList.Add('End;');
            AList.Add('');

            If FUseNestedClass Then
              AList.Add('Function T' + FClsName + 'List.GetEnumerator() : I' + FClsName + 'Enumerator;')
            Else
              AList.Add('Function T' + FClsName + 's.GetEnumerator() : I' + FClsName + 'Enumerator;');

            AList.Add('Begin');
            AList.Add('  Result := T' + FClsName + 'Enumerator.Create(Self);');
            AList.Add('End;');
            AList.Add('');
          End;

          If FUseNestedClass Then
            lClsName := FClsName + 'List'
          Else
            lClsName := FClsName + 's';

          AList.Add('Function T' + lClsName + '.GetItemClass() : TInterfacedObjectExClass;');
          AList.Add('Begin');
          AList.Add('  Result := T' + FClsName + ';');
          AList.Add('End;');
          AList.Add('');
          AList.Add('Function T' + lClsName + '.Get(Index : Integer) : I' + FClsName + ';');
          AList.Add('Begin');
          AList.Add('  Result := InHerited Items[Index] As I' + FClsName + ';');
          AList.Add('End;');
          AList.Add('');
          AList.Add('Procedure T' + lClsName + '.Put(Index : Integer; Const Item : I' + FClsName + ');');
          AList.Add('Begin');
          AList.Add('  InHerited Items[Index] := Item;');
          AList.Add('End;');
          AList.Add('');
          AList.Add('Function T' + lClsName + '.Add() : I' + FClsName + ';');
          AList.Add('Begin');
          AList.Add('  Result := InHerited Add() As I' + FClsName + ';');
          AList.Add('End;');
          AList.Add('');
          AList.Add('Function T' + lClsName + '.Add(Const AItem : I' + FClsName + ') : Integer;');
          AList.Add('Begin');
          AList.Add('  Result := InHerited Add(AItem);');
          AList.Add('End;');
          AList.Add('');
        End
        Else
        Begin
          AList.Add('Function T' + FClsName + 's.GetItem(Index : Integer) : T' + FClsName + ';');
          AList.Add('Begin');
          AList.Add('  Result := InHerited Items[Index] As T' + FClsName + ';');
          AList.Add('End;');
          AList.Add('');
          AList.Add('Procedure T' + FClsName + 's.SetItem(Index : Integer; Const Item : T' + FClsName + ');');
          AList.Add('Begin');
          AList.Add('  InHerited Items[Index] := Item;');
          AList.Add('End;');
        End;
      End;
      {$EndRegion}
    End;

    Finally
      lTmpList.Free();
  End;
End;
</ProcedureImpl>
          <ResultType>rtNone</ResultType>
          <Scope>fsProtected</Scope>
          <IsVirtual>false</IsVirtual>
          <IsAbstract>false</IsAbstract>
          <IsOverRide>false</IsOverRide>
          <IsReIntroduce>false</IsReIntroduce>
          <IsOverLoad>false</IsOverLoad>
          <ShowInInterface>true</ShowInInterface>
        </Procedure>
        <Procedure>
          <Parameters>AList : TStringList</Parameters>
          <ProcedureName>GenerateMSSqlLoadCode</ProcedureName>
          <ProcedureImpl>Var X : Integer;
Begin
  AList.Add('  With ' + FAdoQueryClassName + '.Create(Nil) Do');
  AList.Add('  Try');
  AList.Add('    Sql.Text := ''Select *''#$D#$A + ');
  AList.Add('                ''From ' + FTableName + '''#$D#$A + ');

  For X := 0 To FPropertyDefs.Count - 1 Do
    If FPropertyDefs[X].IsId Then
    Begin
      AList.Add( '                ''Where ' +
                 FPropertyDefs[X].FieldName + ' = :' +
                 FPropertyDefs[X].PropertyName + ''';'
                 );
      AList.Add('');
      AList.Add( '    Parameters.ParamByName(''' +
                 FPropertyDefs[X].PropertyName + ''').Value := AId;');

      Break;
    End;

  AList.Add('    Open();');
  AList.Add('');
  AList.Add('    If Not IsEmpty Then');
  AList.Add('      Self.Assign(Fields);');
  AList.Add('');
  AList.Add('    Finally');
  AList.Add('      Close();');
  AList.Add('      Free();');
  AList.Add('  End;');
End;
</ProcedureImpl>
          <ResultType>rtNone</ResultType>
          <Scope>fsProtected</Scope>
          <IsVirtual>false</IsVirtual>
          <IsAbstract>false</IsAbstract>
          <IsOverRide>false</IsOverRide>
          <IsReIntroduce>false</IsReIntroduce>
          <IsOverLoad>false</IsOverLoad>
          <ShowInInterface>true</ShowInInterface>
        </Procedure>
        <Procedure>
          <Parameters>AList : TStringList</Parameters>
          <ProcedureName>GenerateMSSqlSaveCode</ProcedureName>
          <ProcedureImpl>Var X           : Integer;
    lTmpList    : TStringList;
    lProps      : IHsPropertyDefs;
    lPrimaryKey : IHsPropertyDef;
Begin
  lProps := THsPropertyDefs.Create();
  Try
    For X := 0 To FPropertyDefs.Count - 1 Do
    Begin
      If FPropertyDefs[X].IsDataAware Then
        lProps.Add(FPropertyDefs[X]);
      If FPropertyDefs[X].IsId Then
        lPrimaryKey := FPropertyDefs[X];
    End;
    AList.Add('  If FDataState &gt; edsBrowse Then');
    AList.Add('    With ' + FAdoQueryClassName + '.Create(Nil) Do');
    AList.Add('    Try');
    AList.Add('      If FDataState In [edsAdded, edsModified] Then');
    AList.Add('      Begin');
    AList.Add('        Case FDataState Of');
    AList.Add('          edsAdded :');
    AList.Add('          Begin');

    //InsertQuery
    AList.Add('            Sql.Text := ''Insert Into ' + FTableName + ' (''#$D#$A + ');
    For X := 0 To lProps.Count - 1 Do
    Begin
      If lProps[X].PropertyType &lt;&gt; ptAutoInc Then
      Begin
        If X &lt; lProps.Count - 1 Then
          AList.Add('                        ''' + lProps[X].FieldName + ',''#$D#$A + ')
        Else
          AList.Add('                        ''' + lProps[X].FieldName + '''#$D#$A + ');
      End;
    End;

    AList.Add('                        '') Values (''#$D#$A +');
    For X := 0 To lProps.Count - 1 Do
    Begin
      If lProps[X].PropertyType &lt;&gt; ptAutoInc Then
      Begin
        If X &lt; lProps.Count - 1 Then
          AList.Add('                        '':' + lProps[X].PropertyName + ',''#$D#$A + ')
        Else
        Begin
          If Assigned(lPrimaryKey) And (lPrimaryKey.PropertyType = ptAutoInc) Then
          Begin
            AList.Add('                        '':' + lProps[X].PropertyName + ')''#$D#$A + ');
            AList.Add('                        ''Select Scope_Identity() LastAutoIncValue'';');
          End
          Else
            AList.Add('                        '':' + lProps[X].PropertyName + ')'';');
        End;
      End;
    End;

    AList.Add('          End;');
    AList.Add('');
    AList.Add('          edsModified :');
    AList.Add('          Begin');
    //UpdateQuery
    AList.Add('            Sql.Text := ''Update ' + FTableName + ' Set''#$D#$A + ');
    For X := 0 To lProps.Count - 1 Do
      If Not lProps[X].IsId Then
      Begin
        If X &lt; lProps.Count - 1 Then
          AList.Add('                        ''' + lProps[X].FieldName + ' = :' + lProps[X].PropertyName + ',''#$D#$A + ')
        Else
          AList.Add('                        ''' + lProps[X].FieldName + ' = :' + lProps[X].PropertyName + '''#$D#$A + ');
      End;

    If Assigned(lPrimaryKey) Then
    Begin
      AList.Add('                        ''Where ' + lPrimaryKey.FieldName + ' = :' + lPrimaryKey.PropertyName + ''';');
      AList.Add('');
      AList.Add('            Parameters.ParamByName(''' + lPrimaryKey.PropertyName + ''').Value := F' + lPrimaryKey.PropertyName + ';');
    End;

    AList.Add('          End;');
    AList.Add('        End;');
    AList.Add('');

    //ParamAssign
    lTmpList := TStringList.Create();
    Try
      For X := 0 To lProps.Count - 1 Do
      Begin
        If (lProps[X].PropertyType &lt;&gt; ptAutoInc) Then
          lTmpList.Add('Parameters.ParamByName(''' + lProps[X].PropertyName + ''').Value:=F' + lProps[X].PropertyName + ';');
      End;
      AlignVariableAssign(lTmpList);
      For X := 0 To lTmpList.Count - 1 Do
        AList.Add('      ' + lTmpList[X]);
      Finally
        lTmpList.Free();
    End;

    AList.Add('      End');
    AList.Add('      Else If FDataState = edsDeleted Then');
    AList.Add('      Begin');
    //DeleteQuery
    AList.Add('        Sql.Text := ''Delete From ' + FTableName + '''#$D#$A + ');
    If Assigned(lPrimaryKey) Then
    Begin
      AList.Add('                    ''Where ' + lPrimaryKey.FieldName + ' = :' + lPrimaryKey.PropertyName + ''';');
      AList.Add('        Parameters.ParamByName(''' + lPrimaryKey.PropertyName + ''').Value := F' + lPrimaryKey.PropertyName + ';');
    End;
    AList.Add('      End;');
    AList.Add('');

    If Assigned(lPrimaryKey) And
       (lPrimaryKey.PropertyType = ptAutoInc) Then
    Begin
      AList.Add(PadL('', 6) + 'If FDataState = edsAdded Then');
      AList.Add(PadL('', 6) + 'Begin');
      AList.Add(PadL('', 6) + '  Open();');
      AList.Add(PadL('', 6) + '  F' + lPrimaryKey.PropertyName + ' := FieldByName(''LastAutoIncValue'').AsInteger;');
      AList.Add(PadL('', 6) + 'End');
      AList.Add(PadL('', 6) + 'Else');
      AList.Add(PadL('', 6) + '  ExecSql();');
    End
    Else
      AList.Add('      ExecSql();');

    AList.Add('');
    AList.Add('      Finally');
    AList.Add('        Free();');
    AList.Add('    End;');

    Finally
      lProps := Nil
  End;
End;
</ProcedureImpl>
          <ResultType>rtNone</ResultType>
          <Scope>fsProtected</Scope>
          <IsVirtual>false</IsVirtual>
          <IsAbstract>false</IsAbstract>
          <IsOverRide>false</IsOverRide>
          <IsReIntroduce>false</IsReIntroduce>
          <IsOverLoad>false</IsOverLoad>
          <ShowInInterface>true</ShowInInterface>
        </Procedure>
        <Procedure>
          <Parameters>AList : TStringList</Parameters>
          <ProcedureName>GenerateMSSqlCreateTableCode</ProcedureName>
          <ProcedureImpl>  Function GetFieldType(APropertyType : THsPropertyType) : String;
  Begin
    Case APropertyType Of
      ptByte : Result := 'SmallInt';
      ptBoolean : Result := 'Bit';
      ptInteger :  Result := 'Integer';
      ptAutoInc : Result := 'Integer Identity(1, 1)';
      ptSingle, ptDouble, ptExtended : Result := 'Float';
      ptCurrency : Result := 'Money';
      ptChar, ptString, ptWideString : Result := 'VarChar';
      ptDate, ptTime, ptDateTime : Result := 'DateTime';
    End;
  End;

Var lProps      : IHsPropertyDefs;
    lPrimaryKey : IHsPropertyDef;
    X           : Integer;
    lStr        : String;
Begin
  lProps := THsPropertyDefs.Create();
  Try
    For X := 0 To FPropertyDefs.Count - 1 Do
    Begin
      If FPropertyDefs[X].IsDataAware Then
        lProps.Add(FPropertyDefs[X]);
      If FPropertyDefs[X].IsId Then
        lPrimaryKey := FPropertyDefs[X];
    End;

    AList.Add('  With ' + FAdoQueryClassName + '.Create(Nil) Do');
    AList.Add('  Try');
    AList.Add('    Sql.Text := ''Create Table ' + FTableName + ' (''#$D#$A + ');

    For X := 0 To lProps.Count - 1 Do
    Begin
      lStr := '                ''  ' + lProps[X].FieldName + ' ' + GetFieldType(lProps[X].PropertyType);
      If lProps[X].PropertyType In [ptChar, ptString, ptWideString] Then
      Begin
        If lProps[X].MaxLen &gt; 0 Then
          lStr := lStr + '(' + IntToStr(lProps[X].MaxLen) + ')'
        Else
          lStr := lStr + '(Max)';
      End;

      If (X &lt; lProps.Count - 1) Or Assigned(lPrimaryKey) Then
        lStr := lStr + ',';

      AList.Add(lStr + '''#$D#$A + ');
    End;

    If Assigned(lPrimaryKey) Then
    Begin
      AList.Add('                ''  Constraint Pk' + FTableName + ' Primary Key Clustered''#$D#$A + ');
      AList.Add('                ''  (' + lPrimaryKey.FieldName + ' Asc)''#$D#$A + ');
    End;
    AList.Add('                '')'';');
    AList.Add('    ExecSql();');
    AList.Add('');
    AList.Add('    Finally');
    AList.Add('      Free();');
    AList.Add('  End;');

    Finally
      lProps := Nil;
  End;
End;
</ProcedureImpl>
          <ResultType>rtNone</ResultType>
          <Scope>fsProtected</Scope>
          <IsVirtual>false</IsVirtual>
          <IsAbstract>false</IsAbstract>
          <IsOverRide>false</IsOverRide>
          <IsReIntroduce>false</IsReIntroduce>
          <IsOverLoad>false</IsOverLoad>
          <ShowInInterface>false</ShowInInterface>
        </Procedure>
      </Procedures>
    </ClassDef>
    <ClassDef Name="HsUnitGenerator">
      <Settings>
        <InHeritsFrom/>
        <UseCustomClass>false</UseCustomClass>
        <UseInterface>true</UseInterface>
        <UseStrict>true</UseStrict>
        <MakeList>false</MakeList>
        <UseEnumerator>false</UseEnumerator>
        <UseNestedClass>false</UseNestedClass>
        <TrackChange>false</TrackChange>
        <DataType>dsNone</DataType>
      </Settings>
      <Properies>
        <Property Name="UnitName" PropertyType="ptString">
          <IsReadOnly>false</IsReadOnly>
          <IsDataAware>false</IsDataAware>
          <MaxLen>0</MaxLen>
        </Property>
        <Property Name="TypeDefs" PropertyType="ptInterface">
          <IsReadOnly>true</IsReadOnly>
          <InterfaceName>IHsTypeDefs</InterfaceName>
          <InterfaceImplementor>THsTypeDefs</InterfaceImplementor>
          <IsDataAware>false</IsDataAware>
        </Property>
        <Property Name="ClassDefs" PropertyType="ptInterface">
          <IsReadOnly>true</IsReadOnly>
          <InterfaceName>IHsClassCodeGenerators</InterfaceName>
          <InterfaceImplementor>THsClassCodeGenerators</InterfaceImplementor>
          <IsDataAware>false</IsDataAware>
        </Property>
      </Properies>
      <Procedures>
        <Procedure>
          <Parameters/>
          <ProcedureName>GenerateUnitCode</ProcedureName>
          <ProcedureImpl>Begin

End;
</ProcedureImpl>
          <ResultType>rtString</ResultType>
          <Scope>fsProtected</Scope>
          <IsVirtual>false</IsVirtual>
          <IsAbstract>false</IsAbstract>
          <IsOverRide>false</IsOverRide>
          <IsReIntroduce>false</IsReIntroduce>
          <IsOverLoad>false</IsOverLoad>
          <ShowInInterface>true</ShowInInterface>
        </Procedure>
        <Procedure>
          <Parameters>Const AFileName : String</Parameters>
          <ProcedureName>SaveToFile</ProcedureName>
          <ProcedureImpl>Begin

End;
</ProcedureImpl>
          <ResultType>rtNone</ResultType>
          <Scope>fsProtected</Scope>
          <IsVirtual>false</IsVirtual>
          <IsAbstract>false</IsAbstract>
          <IsOverRide>false</IsOverRide>
          <IsReIntroduce>false</IsReIntroduce>
          <IsOverLoad>false</IsOverLoad>
          <ShowInInterface>true</ShowInInterface>
        </Procedure>
        <Procedure>
          <Parameters>Const AFileName : String</Parameters>
          <ProcedureName>LoadFromFile</ProcedureName>
          <ProcedureImpl>Begin

End;
</ProcedureImpl>
          <ResultType>rtNone</ResultType>
          <Scope>fsProtected</Scope>
          <IsVirtual>false</IsVirtual>
          <IsAbstract>false</IsAbstract>
          <IsOverRide>false</IsOverRide>
          <IsReIntroduce>false</IsReIntroduce>
          <IsOverLoad>false</IsOverLoad>
          <ShowInInterface>true</ShowInInterface>
        </Procedure>
        <Procedure>
          <Parameters>Const ASource : IHsUnitGenerator</Parameters>
          <ProcedureName>Assign</ProcedureName>
          <ProcedureImpl>Begin

End;
</ProcedureImpl>
          <ResultType>rtNone</ResultType>
          <Scope>fsProtected</Scope>
          <IsVirtual>false</IsVirtual>
          <IsAbstract>false</IsAbstract>
          <IsOverRide>false</IsOverRide>
          <IsReIntroduce>false</IsReIntroduce>
          <IsOverLoad>false</IsOverLoad>
          <ShowInInterface>true</ShowInInterface>
        </Procedure>
      </Procedures>
    </ClassDef>
  </ClassDefs>
</UnitDef>
